# 名字空间

 名字空间组织、归类、标识一组具名对象的名字，是模块化编程的重要基础

## 什么是名字空间

名字空间组织、归类、标识一组具名对象的名字，是模块化编程的重要基础。

在名字空间内部定义的对象名字由名字空间管理。
引用外部名字空间的名字时需要在对象名字前添加名字空间前缀。
不同的名字空间中可以有相同的名字而互不干扰，有效的避免了名字污染。

一个名字空间可以包含另一个名字空间，名字之间使用成员操作符"."连接，称为名字空间路径。



## 定义名字空间

使用 namespace 关键字定义名字空间。
如果一个不存在的变量首次被赋值(var语句声明的局部变量除外)，则会自动加入到当前名字空间。
请参考：[赋值语句](the%20language/statements/assignment)

定义名字空间语法：

``` aau
namespace 名字空间名字{

   //名字空间内部代码
}
```

也可以使用begin end定义语句块，如下：

``` aau
namespace 名字空间名字 begin

   //名字空间内部代码
end;
```

名字空间可以嵌套，默认的每一个namespace语句总是在当前名字空间内部创建新的名字空间，如下：

``` aau
namespace 名字空间名字{

   namespace 内部名字空间{

   //名字空间内部代码
   }
}

名字空间名字.内部名字空间.成员 = 123
```

名字空间也可以省略语句块标记，表示名字空间作用域直至该代码文件结束：

``` aau
namespace 名字空间名字

//名字空间内部代码，直到文件结束
```

如果在名字空间前面加上两个连续的小圆点".."作为前缀，则该名字空间为全局名字，如下：

``` aau
namespace 名字空间名字{

   namespace ..全局名字空间{

   //名字空间内部代码
   }
}

全局名字空间.成员 = 123
```

示例如下：

``` aau
io.open(); //打开控制台窗口

namespace 中国.北京{

	温度 = 29;
	天气 = "晴";

	报告气象 = function(){
		//访问全局名字空间要加上..前缀
		..io.open();
		..io.print("温度",温度)
		..io.print("天气",天气)
	}

}

中国.北京.报告气象()
```

名字空间其实也是一个普通的table对象。
访问非当前名字空间的成员变量,可以加上有效的名字空间前缀.访问顶层名字空间要使用..操作符。

## global,self

### 1、global

global为默认的全局名字空间，当aardio代码文件加载时，默认都运行在global名字空间。


### 2、self

self表示当前名字空间。

## import语句

import语句可以将外部名字空间导入当前名字空间（并且总是会同时导入全局名字空间），如下：

``` aau
namespace 中国.北京{

	..io.open(); //注意访问全局名字空间需要添加..前缀

   import io; //导入到当前名字空间
   io.print("io已经在当前名字空间了")

}
```

如果是不存在的名字空间，import会尝试导入库文件。
aardio库文件的物理路径与名字空间路径完全一致，对于模块化编程提供良好的支持。

注意：`名字空间不能是单个下划线(可以包含下划线)!`

请参考: [import](libraries/import)
