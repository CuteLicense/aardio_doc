# 运算符重载

 对于一个table对象，我们可以重载运算符使操作数执行自定义的运算函数。

## 一、元方法

每个table都可以指定一个[元表(metatable)](libraries/kernel/table/meta)，在元表中可以重载运算符。
重载的操作符实际上是一个函数，称之为表的[元方法](the%20language/%D4%CB%CB%E3%B7%FB/2/metatable)。

以@操作符表示元表。例如tab@表示tab的元表。
也可以在表构造器中直接用@指定元表，例如：tab={ n=123;n2=456;@{ _type = "自定义元表"} }
table的元表可以是table自已。例: tab@ = tab;

 下面是使用元表重载运算符的示例：

``` aau
io.open(); tab = { x=10 ; y=20 };
tab2 = { x=12 ; y=22 }
//c = tab + tab2; //这样肯定会出错，因为 table默认是不能相加的

//创建一个元素，元表中的__add函数重载加运算符。
tab@ = {
	_add = function(b) begin
		return owner.x + b.x
	end;
}

c = tab + tab2; //这时候会调用重载的操作符 tab@._add(tab2)
io.print( c ) //显示22
```




|  元方法 |  说明 |
| --- | --- |
| _weak |  弱引用不会增加引用计数、不会阻止垃圾回收器删除对象。 赋值为 "kv" 表示弱引用键、值。 赋值为 "v"　表示弱引用值。 赋值为 "k" 表示弱引用键。 |
|  _type |  自定义类型,如果值为"object",指明该对象为为JSON兼容的对象， 如果值为"array",指明该对象为为JSON的数组。 |
|  _defined |  用于返回对象的预定义已排序键名，被用于table.eachName等函数。 |
|  _keys |  可用于table.keys等函数动态获取对象的键名列表（例如动态生成键值对的外部JS对象可使用这个元方法返回成员名字列表）。 |
|  _startIndex |  用于table.eachIndex等函数动态指定数组的开始下标。 |
| _get = function(k,ownerCall) {} | 索引操作符[]如果读取表中不存在的键会触发_get元方法并返回值。_get不但可以是一个函数,也可以是一个table对象(找不到成员就到_get指定的table里找)，如果是一个函数，调用参数k为键名,ownerCall如果为真则应当返回一个函数 - 这表示使用 对象.函数名() 的格式获取并调用成员函数。 |
| _set = function(k,v) {} | 索引操作符[]当你给表的一个缺少的键赋值时会触发_set元方法。参数k为键名,参数v为新值 |
| _eq = function(b){} | 相等运算、不等运算符 调用此元方法并取反 比较的两个对象必须指向相同的元方法(即 a@._eq === b@._eq ),否则默认规则进行比较. |
| _le = function(b){} |  小于等于、大于等于运算符 比较的两个对象必须指向相同的元方法(即 a@._eq === b@._eq ) 当调用 a <= b 时, a为元方法的owner对象(左参数) 当调用 a >= b 时, b为元方法的owner对象(右参数作为左参数) |
| _lt = function(b){} |  小于运算、大于运算符 比较的两个对象必须指向相同的元方法(即 a@._eq === b@._eq ) 当调用 a < b 时, a为元方法的owner对象(左参数) 当调用 a > b 时, b为元方法的owner对象(右参数作为左参数) |
| _add = function(b){} |  加运算符 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _sub = function(b){} |  减运算符 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _mul = function(b){} | 乘运算符 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _div = function(b){} |  除运算符 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _lshift = function(b){} |  左移运算符 <<调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _rshift = function(b){} |  右移运算符 >> 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _mod = function(b){} |  模运算符 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _pow = function(b){} |  幂运算符 调用元方法时,始终取左操作数作为元方法的owner参数. 无论左操作数或右操作参数定义了此元方法,都可以触发自定义的运算. 当左右操作数定义了不同的元方法,调用左操作数的元方法. |
| _unm = function(b){} |  取负运算符 |
| _len = function(b){} |  取长运算符(table,string,null 这三种类型不支持) |
| _concat = function(b){} |  连接运算符 |
| _call = function(b){} |  函数调用 |



一个常见的技巧，table是按引用比较的，即使他们的值相同，但只要不是指向同一个对象都被认为是不相等，
我们通过重载==运算符可以让两个tab按他们的存储值比较。
io.open();

tab = { x=10 ; y=20 };
tab2 = { x=10 ; y=20 }
io.print( tab == tab2 ); //默认是按引用比较，不指向同一个对象就不相等，结果为false

//创建一个元素，元表中的__eq函数重载比较运算符"=="。
tab@ = {
_eq = function( b){ 
return ( (owner.x == b.x) and (owner.y == b.y) )
};
}
tab2@ = tab@;//为tab2添加元表， 比较运算符需要为两个操作数添加同一个元表。
io.print( tab==tab2 ); //现在可以使用重载的==操作符按值比较了

## 避免元方法递归调用导致溢出

``` aau
dic ={

	//创建元表
	@{
		_tostring = function() {
			..io.print( owner ); //递归调用了_tostring元方法，会导致堆栈溢出。
			return "aaa";
		}
	}

}

io.print( dic )  //io.print会自动调用tostring(参数)
```

例如你有这么一个对象dic，他重载了_tostring这个元方法。
那么在调用 io.print( dic ) 时就会自动调用 io.print( tostring(dic) )
可是你在元方法里又写了..io.print( owner ) ，问题就来了，owner就是他自已，这样又要调用tostring(owner) 而这样又会调用元方法，而元方法又再次调用 tostring(owner) 这样没完没了的递归，所以就出错了。

这里只是举一个例子，类似的还有在索引元方法_get 的内部写owner["key"]
owner["key"] 又会调用 _get元方法，而_get元方法又会调用 owner["key"] 也是这样没完没了。

aardio为了避免这个问题，提供了raw操作符。
而[[]] 就是一个raw操作符，他与[]不同的是，他不会调用元方法，也就是不能重载。
也就是说，在_get元方法里写 owner[["key"]] 就可以避免出现上述的递归调用错误。

