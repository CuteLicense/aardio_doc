# 闭包

 请参考：[定义函数](the%20language/function/definitions)

## 闭包(Closure)

**1、闭包的创建**

一个函数一般会是在另一个函数内部创建,代码文件本身也是一个匿名函数。

函数内部的局部变量仅在函数内部有效.
函数不但可以使用函数内部定义的局部变量,而且可以使用外部函数已经定义的局部变量(upvariable);
即使外部的函数已销毁,这些外部的局部变量(upvariable)仍然保持一个独立的闭包中.

每次调用一个外部函数,aardio总是会为该函数内部的函数创建一个新的闭包.
闭包限制闭包内定义的局部变量仅在闭包内部有效，闭包有保护私有数据的作用。
闭包保存一个函数需要引用的外部的局部变量(upvariable),闭包有保护函数运行环境的作用.

**2、闭包的生命周期**

在外部函数调用结束后，闭包仍然可以存在.
直到闭包内的所有内部函数都销毁，并且不再有任何外部对象引用到闭包内的数据，闭包会被垃圾回收器自动回收。

函数创建闭包的过程类似于创建对象的过程，区别在于创建闭包的是函数、闭包返回的是函数对象，
而类返回的是table对象，而由类创建的对象可以有公开的成员对象。而闭包则完全是黑盒机制，只有受保护的私有数据。

下面是一个创建闭包的示例：

``` aau
io.open();

function 创建闭包(){

	var upvar = 23;

	var 子函数 = function() { //函数里面可以定义子函数
		io.print(upvar); //函数可以使用上层函数定义的局部变量
		upvar +=1;
	}

	return 子函数;

}

子函数 = 创建闭包(); //创建了新的闭包

子函数()
子函数() //闭包内部的upv被+1变成了24

子函数2 = 创建闭包(); //创建了新的闭包
子函数2() //子函数2所在的闭包内upvar的值还是23
```

在函数内部的函数，如果不在函数定义前面加上var语句，实际上等于定义了一个全局函数。
但是他同样可以使用上层函数的闭包内的数据，直到该函数不再有任何引用。

## 迭代器

迭代器是闭包的应用之一，请参考：[for in语句、迭代器](the%20language/statements/looping#forin)
