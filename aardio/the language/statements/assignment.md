# 赋值语句

## **一、普通赋值** 语句


 赋值语句改变一个变量的值。
 赋值语句不会返回操作数，不能作为表达式的一部分。
 赋值语句必须是独立的语句。v = v2 = 100 的写法是错误的。


### 1.1、 **赋值**

> 例如: a = 120;
如果将一个变量赋值为null等同删除这个变量
table,cdata,function.类型的数据在赋值时并不会创建新的值而只是添加一个引用(即新变量仍然指向同一个对象)。将数据作为函数的参数时也会进行赋值操作，作为参数table,cdata,function 同样是按引用传递的。

### 1.2、 **多重赋值**

> a,b,c = 1,2,3;
以上的写法等效于 a=1;b=2;c=3;
多重赋值时，右边的操作数如果多于左边的变量数目则丢弃多余的，不足则返回null。
a,b,c = 0; 结果是a等于 0 ,![](../../icon/ok.gif)b,c都等于null。![](../../icon/error.gif)而不是a,b,c都等于0。
如果一个函数有多个返回值时，也可以使用多重赋值的方法，例如：

a,b,c = table.unpack( { 1 ; 2 ; 3 } )

### 1.2、 **使用赋值** 语句定义变量、常量

> 对于一个从未使用过的变量，其值为null，首次使用赋值语句声明一个变量。//将变量声明为当前名字空间下的成员变量
value = 100;

//以下划线开始的成员常量，只能赋值一次
 _value = 100; 

//以下划线开始的全局常量，只能赋值一次 
 _VALUE = 100; 

//使用::操作符定义的全局常量，只能赋值一次 
::Value = 100; 

### 1.3、 **使用var赋值** 语句定义局部变量

> 局部变量需要用var语句声明。
使用局部变量有两个好处 1.避免命名冲突 2.访问局部变量的速度比全局变量更快.

请参考：[局部变量](the%20language/variables%20constants#var) [函数局部变量](the%20language/function/definitions#var)

示例:
io.open();

  

  var str = "123"; //声明一个变量str,str是一个合乎语法的标识符，存储的值为字符串"123"，您可以改变str的值。

  

  begin //语句块开始

     var str = "hello" //var语句声明的局部变量str仅在语句块内部有效

     str   ="hello world!" //变量的值是可以改变的

     io.print(str); //显示hello world

  end; //语句块结束

  

io.print(str); //显示123  

允许合并定义局部变量的var语句，格式如下：

``` aau
var (
	a = 123;
	b = 456
);
```


如果var后面使用一对括号,则内部可以写多条var语句并省略前面的var关键字

### 1.2、使用赋值语句 **删除变量**

> 将一个变量赋值为null，删除这个变量。例：

x = null

## 二、复合赋值语句

a= a + b 可以写成 a += b
所有二元操作符都可以按上述规则书写。

例如：
a -= b;
a *= b;

 复合赋值操作符不能包含空格，如 a + = b; 是错误的，正确的应当是 a += b ;![](../../icon/ok.gif)

## 三、初始赋值语句

A := c 也就是 A = A:c
如果A为null空值，则将c赋值给A。

定义常量时，为避免重复赋值，通常使用初始化赋值语句。


## 四、条件赋值语句

str ?= string.lower(str) 

上面的语句等价于： str = str and string.lower(str)

如果str不为null空值，则执行后面的赋值语句。
其语义如下：
if(str != null)
{
str = string.lower(str)
} 


这样可以避免str为null空值时，string.lower抛出错误。
如果str为空，则等号右侧的语句根本不会执行。

## 五、自增自减赋值

a++; 等价于 a += 1;
a--; 等价于 a -= 1;
